#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define IP_TRACKER_COUNT 64 // Number of IP trackers
// ------------------------- DO NOT CHANGE -------------------------------- //

#define PREFETCH_DEGREE 8 // Prefetch degree - you need to vary this!

// Define states for stride consistency
#define INITIAL 0
#define STEADY 1
#define TRANSIENT 2
#define NO_PRED 3

class IP_TRACKER
{
public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;         // Instruction pointer
    uint64_t last_addr;  // Last address referenced
    int64_t last_stride; // Last stride calculated
    int state;           // State of the tracker

    IP_TRACKER()
    {
        ip = 0;
        last_addr = 0;
        last_stride = 0;
        state = INITIAL;
    }
};

IP_TRACKER trackers[IP_TRACKER_COUNT];

// ------------------------- Initialize the prefetcher ------------------------- //
void CACHE::stlb_prefetcher_initialize()
{
    cout << "CPU " << cpu << " STLB arbitrary stride prefetcher" << endl;
    for (int i = 0; i < IP_TRACKER_COUNT; i++)
    {
        trackers[i] = IP_TRACKER(); // Initialize each tracker
    }
}

// --------------- This is the main prefetcher operate function ---------------- //
void CACHE::stlb_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint64_t prefetch_id, uint8_t instruction)
{
    // ------------------------ Add Arbitrary Stride pf_address logic here ----------------------- //

    // Search for the IP in the tracker table
    int tracker_index = -1;
    for (int i = 0; i < IP_TRACKER_COUNT; i++)
    {
        if (trackers[i].ip == ip || trackers[i].ip == 0)
        {
            tracker_index = i;
            break;
        }
    }

    if (tracker_index == -1)
        return; // No available tracker

    IP_TRACKER *tracker = &trackers[tracker_index];

    // Update the tracker IP if it's a new entry
    if (tracker->ip == 0)
    {
        tracker->ip = ip;
        tracker->last_addr = addr;
        tracker->state = INITIAL;
        return;
    }

    // Calculate the stride
    int64_t stride = addr - tracker->last_addr;

    // State machine logic to handle stride consistency
    switch (tracker->state)
    {
    case INITIAL:
        if (stride != 0)
        {
            tracker->last_stride = stride;
            tracker->state = TRANSIENT;
        }
        break;

    case TRANSIENT:
        if (stride == tracker->last_stride)
        {
            tracker->state = STEADY;
        }
        else
        {
            tracker->last_stride = stride;
        }
        break;

    case STEADY:
        if (stride != tracker->last_stride)
        {
            tracker->state = INITIAL;
        }
        break;

    default:
        tracker->state = INITIAL;
        break;
    }

    tracker->last_addr = addr;

        // Prefetch logic: Prefetch only if in the STEADY state
    if ( tracker->state == STEADY)
    {
        for (int i = 1; i <= PREFETCH_DEGREE; i++)
        {
            uint64_t pf_address = addr + (i * tracker->last_stride);

            // Prefetch the calculated address
            prefetch_translation(ip, pf_address, (int)2, 0, prefetch_id, instruction);
        }
    }

    return;
}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::stlb_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    return;
}

void CACHE::stlb_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " STLB arbitrary stride prefetcher final stats" << endl;
    cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //